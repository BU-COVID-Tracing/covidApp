{"version":3,"sources":["getStateFromPath.tsx"],"names":["escape","queryString","getStateFromPath","path","options","initialRoutes","configs","concat","Object","keys","map","key","createNormalizedConfigs","sort","a","b","pattern","startsWith","aParts","split","bParts","aWildcardIndex","indexOf","bWildcardIndex","length","remaining","replace","endsWith","match","find","config","routeNames","every","name","c","screen","createNestedStateObject","i","self","params","parseQueryParams","parse","undefined","result","current","allParams","remainingPath","matchAgainstConfigs","regex","RegExp","source","createRouteObjects","segments","decodeURIComponent","shift","join","state","routes","index","route","findFocusedRoute","findParseConfigForRoute","joinPaths","paths","p","filter","Boolean","paramPatterns","reduce","acc","value","routeConfig","initials","parentPattern","push","createConfigItem","exact","screens","initialRouteName","connectedRoutes","forEach","nestedConfig","pop","it","routeName","flatConfig","findInitialRoute","includes","createStateObject","initialRoute","isEmpty","nestedState","nestedStateIndex","parseConfig","query"],"mappings":"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","sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\nimport { PathConfig } from './types';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype RouteConfig = {\n  screen: string;\n  regex?: RegExp;\n  path: string;\n  pattern: string;\n  routeNames: string[];\n  parse?: ParseConfig;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: PathConfig = {}\n): ResultState | undefined {\n  let initialRoutes: InitialRouteConfig[] = [];\n\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[])\n    .concat(\n      ...Object.keys(options).map((key) =>\n        createNormalizedConfigs(key, options, [], initialRoutes)\n      )\n    )\n    .sort((a, b) => {\n      // Sort config so that:\n      // - the most exhaustive ones are always at the beginning\n      // - patterns with wildcard are always at the end\n\n      // If one of the patterns starts with the other, it's more exhaustive\n      // So move it up\n      if (a.pattern.startsWith(b.pattern)) {\n        return 1;\n      }\n\n      if (b.pattern.startsWith(a.pattern)) {\n        return 1;\n      }\n\n      const aParts = a.pattern.split('/');\n      const bParts = b.pattern.split('/');\n\n      const aWildcardIndex = aParts.indexOf('*');\n      const bWildcardIndex = bParts.indexOf('*');\n\n      // If only one of the patterns has a wildcard, move it down in the list\n      if (aWildcardIndex === -1 && bWildcardIndex !== -1) {\n        return -1;\n      }\n\n      if (aWildcardIndex !== -1 && bWildcardIndex === -1) {\n        return 1;\n      }\n\n      if (aWildcardIndex === bWildcardIndex) {\n        // If `b` has more `/`, it's more exhaustive\n        // So we move it up in the list\n        return bParts.length - aParts.length;\n      }\n\n      // If the wildcard appears later in the pattern (has higher index), it's more specific\n      // So we move it up in the list\n      return bWildcardIndex - aWildcardIndex;\n    });\n\n  let remaining = path\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find(\n      (config) =>\n        config.path === '' &&\n        config.routeNames.every(\n          // Make sure that none of the parent configs have a non-empty path defined\n          (name) => !configs.find((c) => c.screen === name)?.path\n        )\n    );\n\n    if (match) {\n      return createNestedStateObject(\n        match.routeNames.map((name, i, self) => {\n          if (i === self.length - 1) {\n            return { name, params: parseQueryParams(path, match.parse) };\n          }\n\n          return { name };\n        }),\n        initialRoutes\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  // We try to match the paths in 2 passes\n  // In first pass, we match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const { routeNames, allParams, remainingPath } = matchAgainstConfigs(\n    remaining,\n    configs.map((c) => ({\n      ...c,\n      // Add `$` to the regex to make sure it matches till end of the path and not just beginning\n      regex: c.regex ? new RegExp(c.regex.source + '$') : undefined,\n    }))\n  );\n\n  if (routeNames !== undefined) {\n    // This will always be empty if full path matched\n    remaining = remainingPath;\n    current = createNestedStateObject(\n      createRouteObjects(configs, routeNames, allParams),\n      initialRoutes\n    );\n    result = current;\n  }\n\n  // In second pass, we divide the path into segments and match piece by piece\n  // This preserves the old behaviour, but we should remove it in next major\n  while (remaining) {\n    let { routeNames, allParams, remainingPath } = matchAgainstConfigs(\n      remaining,\n      configs\n    );\n\n    remaining = remainingPath;\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    const state = createNestedStateObject(\n      createRouteObjects(configs, routeNames, allParams),\n      initialRoutes\n    );\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const route = findFocusedRoute(current);\n  const params = parseQueryParams(\n    path,\n    findParseConfigForRoute(route.name, configs)\n  );\n\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst matchAgainstConfigs = (remaining: string, configs: RouteConfig[]) => {\n  let routeNames: string[] | undefined;\n  let allParams: Record<string, any> | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (match) {\n      routeNames = [...config.routeNames];\n\n      const paramPatterns = config.pattern\n        .split('/')\n        .filter((p) => p.startsWith(':'));\n\n      if (paramPatterns.length) {\n        allParams = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n          const value = match![(i + 1) * 2].replace(/\\//, ''); // The param segments appear every second item starting from 2 in the regex match result\n\n          acc[p] = value;\n\n          return acc;\n        }, {});\n      }\n\n      remainingPath = remainingPath.replace(match[1], '');\n\n      break;\n    }\n  }\n\n  return { routeNames, allParams, remainingPath };\n};\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: PathConfig,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[],\n  parentPattern?: string\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  const config = routeConfig[screen];\n\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    configs.push(createConfigItem(screen, routeNames, pattern, config));\n  } else if (typeof config === 'object') {\n    let pattern: string | undefined;\n\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      pattern =\n        config.exact !== true && parentPattern\n          ? joinPaths(parentPattern, config.path)\n          : config.path;\n\n      configs.push(\n        createConfigItem(screen, routeNames, pattern, config.path, config.parse)\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          connectedRoutes: Object.keys(config.screens),\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as PathConfig,\n          routeNames,\n          initials,\n          pattern\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  path: string,\n  parse?: ParseConfig\n): RouteConfig => {\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n  pattern = pattern.split('/').filter(Boolean).join('/');\n\n  const regex = pattern\n    ? new RegExp(\n        `^(${pattern\n          .split('/')\n          .map((it) => {\n            if (it.startsWith(':')) {\n              return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n            }\n\n            return `${it === '*' ? '.*' : escape(it)}\\\\/`;\n          })\n          .join('')})`\n      )\n    : undefined;\n\n  return {\n    screen,\n    regex,\n    pattern,\n    path,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  routeName: string,\n  params: Record<string, any> | undefined,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, { name: routeName as string, params }],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, params }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, params, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, params, state: { routes: [] } }],\n      };\n    }\n  }\n};\n\nconst createNestedStateObject = (\n  routes: { name: string; params?: object }[],\n  initialRoutes: InitialRouteConfig[]\n) => {\n  let state: InitialState;\n  let route = routes.shift() as { name: string; params?: object };\n  let initialRoute = findInitialRoute(route.name, initialRoutes);\n\n  state = createStateObject(\n    initialRoute,\n    route.name,\n    route.params,\n    routes.length === 0\n  );\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as { name: string; params?: object })) {\n      initialRoute = findInitialRoute(route.name, initialRoutes);\n\n      const nestedStateIndex =\n        nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route.name,\n        route.params,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex]\n          .state as InitialState;\n      }\n    }\n  }\n\n  return state;\n};\n\nconst createRouteObjects = (\n  configs: RouteConfig[],\n  routeNames: string[],\n  allParams?: Record<string, any>\n) =>\n  routeNames.map((name) => {\n    const config = configs.find((c) => c.screen === name);\n\n    let params: object | undefined;\n\n    if (allParams && config?.path) {\n      const pattern = config.path;\n\n      if (pattern) {\n        const paramPatterns = pattern\n          .split('/')\n          .filter((p) => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p) => {\n            const key = p.replace(/^:/, '').replace(/\\?$/, '');\n            const value = allParams![p];\n\n            if (value) {\n              acc[key] =\n                config.parse && config.parse[key]\n                  ? config.parse[key](value)\n                  : value;\n            }\n\n            return acc;\n          }, {});\n        }\n      }\n    }\n\n    if (params && Object.keys(params).length) {\n      return { name, params };\n    }\n\n    return { name };\n  });\n\nconst findFocusedRoute = (state: InitialState) => {\n  let current: InitialState | undefined = state;\n\n  while (current?.routes[current.index || 0].state) {\n    // The query params apply to the deepest route\n    current = current.routes[current.index || 0].state;\n  }\n\n  const route = (current as PartialState<NavigationState>).routes[\n    current?.index || 0\n  ];\n\n  return route;\n};\n\nconst parseQueryParams = (\n  path: string,\n  parseConfig?: Record<string, (value: string) => any>\n) => {\n  const query = path.split('?')[1];\n  const params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (parseConfig[name] && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n"]}